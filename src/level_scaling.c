#include <pmdsky.h>
#include <cot.h>
#include "extern.h"

/*
  Returns the highest level across the current active team. If no valid team members are found, the max returned is 0.
*/
uint8_t GetHighestLevelTeamMember(void) {
    uint8_t max = 0;
    for(int i = 0; i < 4; i++) {
        struct team_member* member = GetActiveTeamMember(i);
        if(member != NULL && member->f_is_valid && member->level > max)
            max = member->level;
    }
    return max;
}

/*
  Determines how to initialize a ground monster that has its data stem from a guest monster.
  If a condition is met, then the ground monster will become the level of the highest team member and have its stats and moves adjusted accordingly.
  A moveset is generated by taking only the first four possible moves from a monster's level up learnset.

  TODO: Use a proper condition for the check and possibly rethink how moves are generated.
*/
__attribute((used)) void CustomGuestMonsterToGroundMonster(struct ground_monster* ground_monster, struct guest_monster* guest_monster) {
    if(apSettings.levelScaleGuests && apSettings.levelScalingMode != LEVEL_SCALING_OFF) {
        ground_monster->is_valid = true;
        ground_monster->id = guest_monster->id;
        ground_monster->tactic.val = TACTIC_LETS_GO_TOGETHER;
        ground_monster->joined_at = guest_monster->joined_at;
        ground_monster->joined_at = guest_monster->joined_at;
        ground_monster->joined_at_floor = guest_monster->joined_at_floor;
        ground_monster->level_at_first_evo = 0;
        ground_monster->level_at_second_evo = 0;
        SetBaseStatsMovesGroundMonster(ground_monster);
        ground_monster->iq = guest_monster->iq;
        ApplyLevelUpBoostsToGroundMonster(ground_monster, GetHighestLevelTeamMember(), false);
        EnableAllLearnableIqSkills(ground_monster->iq_skill_flags, ground_monster->id.val, ground_monster->iq);
        StrncpySimple(ground_monster->name, guest_monster->name, 10);
    }
    else
        GuestMonsterToGroundMonster(ground_monster, guest_monster);
}

__attribute((naked)) void DoLevelScalingWrapper(){ // just so we don't fuck up the registers...
  asm("stmdb sp!,{r0-r8, lr}");
  asm("bl DoLevelScaling");
  asm("ldmia sp!,{r0-r8, lr}");
  asm("b IsFullFloorFixedRoom"); // original instruction
}

void DoLevelScaling(){
  uint8_t dungeonId = DUNGEON_PTR->id.val;
  if((dungeonId >= 123 && dungeonId <= 164) || apSettings.levelScalingMode == LEVEL_SCALING_OFF) return; // block level scaling if we're in an SE dungeon or if level scaling is disabled.
  int maxLevel_mult_512 = GetHighestLevelTeamMember() << 9; // for some reason in the struct, the spawn level is stored as level << 9... so we bitshift it now.
  for (int i = 0; i < 16; i++){ // iterate through spawn_entries_master
    struct monster_spawn_entry enemy = DUNGEON_PTR->spawn_entries_master[i];
    uint16_t enemyLevel_mult_512 = enemy.level_mult_512;
    // there are four conditions for scaling, detailed below. i *could* cram it all into one line but i figured this would be better for readability.
    bool shouldScale = enemyLevel_mult_512 > maxLevel_mult_512; // only scale if the enemy is ABOVE that the party
    shouldScale |= apSettings.levelScalingMode == LEVEL_SCALING_DIFFICULT; // UNLESS on difficult mode, in which case we should scale regardless of the enemy level.
    shouldScale &= enemyLevel_mult_512 > 512; // we should NEVER scale an enemy if they're level 1 or 0.
    shouldScale &= FemaleToMaleForm(enemy.id.val) != 383; // oh and kecleon can't scale either. sorry lappy
    if(shouldScale) {
      DUNGEON_PTR->spawn_entries_master[i].level_mult_512 = maxLevel_mult_512;
    }
  }
}